首先下载frp服务端包，然后解压到frp目录下！
以 frp\_0.65.0\_linux\_amd64.tar.gz 为例，运行新建frp目录并解压命令：

```
mkdir frp && tar -zxf frp_0.65.0_linux_amd64.tar.gz --strip-components=1 -C frp
```

服务端frps.toml模板
==============

```
# frps.toml
bindPort = 7500

# 用于 kcp 协议的 udp 端口，可以与 'bindPort' 相同。
# 如果未设置，则在 frps 中禁用 kcp。
kcpBindPort = 7500

# transport.tls.force 指定是否仅接受 TLS 加密连接。默认值为 false。
transport.tls.force = true
transport.tls.certFile = "/root/frp_cert/server.crt"
transport.tls.keyFile = "/root/frp_cert/server.key"
transport.tls.trustedCaFile = "/root/frp_cert/ca.crt"

# 配置 web 服务器以启用 frps 的仪表板。
# 仪表板仅在设置了 webServer.port 时可用。
webServer.addr = "0.0.0.0"
webServer.port = 8000
webServer.user = "admin"
webServer.password = "xxxxxx"
# webServer.tls.certFile = "server.crt"
# webServer.tls.keyFile = "server.key"

# token 认证
auth.method = "token"
auth.token = "xxxxxx"
```

客户端frpc.toml简易模板(通过服务端VPS中转)
============================

```
# frpc.toml
serverAddr = "x.x.x.x"
serverPort = 7500
auth.method = "token"
auth.token = "xxxxxx"

[[proxies]]
name = "rdp"
type = "tcp"
localIP = "127.0.0.1"
localPort = xxxx
remotePort = xxxx
```

客户端frpc.toml-A模板(P2P直连被访问端)
===========================

```
# frpc.toml
serverAddr = "x.x.x.x"
serverPort = 7500
# 如果默认的 STUN 服务器不可用，可以配置一个新的 STUN 服务器
natHoleStunServer = "stun.easyvoip.com:3478"

auth.method = "token"
auth.token = "xxxxxx"

[[proxies]]
name = "RDP"
type = "xtcp"
# 只有共享密钥 (secretKey) 与服务器端一致的用户才能访问该服务
secretKey = "xxxxxx"
localIP = "127.0.0.1"
localPort = 3389
transport.useEncryption = false
```

客户端frpc.toml-B模板(P2P直连访问端)
==========================

```
# frpc.toml
serverAddr = "x.x.x.x"
serverPort = 7500
# 如果默认的 STUN 服务器不可用，可以配置一个新的 STUN 服务器
natHoleStunServer = "stun.easyvoip.com:3478"

auth.method = "token"
auth.token = "xxxxxx"

# TLS 配置（如果frps端开启了TLS）
transport.tls.enable = true
transport.tls.certFile = "./client.crt"
transport.tls.keyFile = "./client.key"
transport.tls.trustedCaFile = "./ca.crt"

[[visitors]]
name = "RDP_visitor_A"
type = "xtcp"
# 要访问的 P2P 代理的名称
serverName = "RDP_A"
secretKey = "xxxxxx"
bindAddr = "127.0.0.1"
bindPort = 19969
transport.useEncryption = false

[[visitors]]
name = "RDP_visitor_B"
type = "xtcp"
# 要访问的 P2P 代理的名称
serverName = "RDP_B"
secretKey = "xxxxxx"
bindAddr = "127.0.0.1"
bindPort = 19979
transport.useEncryption = true
```

服务端证书申请步骤
=========

1. 创建目录并生成证书

```
mkdir -p /root/frp_cert
cd /root/frp_cert
```

2. 设置 IP 变量（替换成你的实际 IP）

```
SERVER_IP="x.x.x.x"
```

3. 创建 OpenSSL 配置文件

```
cat > my-openssl.cnf << EOF
[ ca ]
default_ca = CA_default
[ CA_default ]
x509_extensions = usr_cert
[ req ]
default_bits        = 2048
default_md          = sha256
default_keyfile     = privkey.pem
distinguished_name  = req_distinguished_name
attributes          = req_attributes
x509_extensions     = v3_ca
string_mask         = utf8only
[ req_distinguished_name ]
[ req_attributes ]
[ usr_cert ]
basicConstraints       = CA:FALSE
nsComment              = "OpenSSL Generated Certificate"
subjectKeyIdentifier   = hash
authorityKeyIdentifier = keyid,issuer
[ v3_ca ]
subjectKeyIdentifier   = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints       = CA:true
EOF
```

4. 生成 CA 证书

```
openssl genrsa -out ca.key 2048
openssl req -x509 -new -nodes -key ca.key -subj "/CN=FRP-Root-CA" -days 5000 -out ca.crt
```

5. 生成服务端私钥和证书

```
openssl genrsa -out server.key 2048

openssl req -new -sha256 -key server.key \
    -subj "/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=${SERVER_IP}" \
    -reqexts SAN \
    -config <(cat my-openssl.cnf <(printf "\n[SAN]\nsubjectAltName=IP:${SERVER_IP}")) \
    -out server.csr

openssl x509 -req -days 365 -sha256 \
	-in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
	-extfile <(printf "subjectAltName=IP:${SERVER_IP}") \
	-out server.crt
```

6. 生成客户端私钥和证书

```
openssl genrsa -out client.key 2048

openssl req -new -sha256 -key client.key \
    -subj "/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=frp-client" \
    -reqexts SAN \
    -config <(cat my-openssl.cnf <(printf "\n[SAN]\nsubjectAltName=DNS:frp-client")) \
    -out client.csr

openssl x509 -req -days 365 -sha256 \
    -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
	-extfile <(printf "subjectAltName=DNS:frp-client") \
	-out client.crt
```

7. 删除临时文件

```
rm server.csr client.csr ca.srl
```

8. 服务端 frps.toml 中配置

```
# transport.tls.force 指定是否仅接受 TLS 加密连接。默认值为 false。
transport.tls.force = true
transport.tls.certFile = "/root/frp_cert/server.crt"
transport.tls.keyFile = "/root/frp_cert/server.key"
transport.tls.trustedCaFile = "/root/frp_cert/ca.crt"
```

9. 客户端 frpc.toml 中配置
将 /root/frp\_cert/ca.crt 复制到客户端机器，然后在客户端的 frpc.toml 中配置：

```
# TLS 配置
transport.tls.enable = true
transport.tls.certFile = "./client.crt"
transport.tls.keyFile = "./client.key"
transport.tls.trustedCaFile = "./ca.crt"
```

Linux服务端自启动模板
=============

新建文件：frps.service
将文件放在目录/etc/systemd/system/frps.service

```
[Unit]
# 服务名称，可自定义
Description = FRP Server
After = network.target syslog.target
Wants = network.target

[Service]
Type = simple
# 启动frps的命令，需修改为您的frps的安装路径
ExecStart = /root/frp/frps -c /root/frp/frps.toml

[Install]
WantedBy = multi-user.target
```

Linux服务端自启动命令
-------------

重新加载配置

```
systemctl daemon-reload
```

开机自启动

```
systemctl enable frps
```

关闭开机自启动

```
systemctl disable frps
```

重启frps

```
systemctl restart frps
```

停止frps

```
systemctl stop frps
```

查看frps状态

```
systemctl status frps
```

以下是frps\_full\_example.toml （0.65.0版本）toml文件的中文注释版：
---------------------------------------------------

```
# 此配置文件仅供参考。请勿直接使用此配置运行程序，因为它可能存在各种问题。

# IPv6 的字面地址或主机名必须用方括号括起来
# 例如 "[::1]:80", "[ipv6-host]:http" 或 "[ipv6-host%zone]:80"
# 对于单独的 "bindAddr" 字段，不需要方括号，如 `bindAddr = "::"`。
bindAddr = "0.0.0.0"
bindPort = 7000

# 用于 kcp 协议的 udp 端口，可以与 'bindPort' 相同。
# 如果未设置，则在 frps 中禁用 kcp。
kcpBindPort = 7000

# 用于 quic 协议的 udp 端口。
# 如果未设置，则在 frps 中禁用 quic。
# quicBindPort = 7002

# 指定代理将监听的地址，默认值与 bindAddr 相同
# proxyBindAddr = "127.0.0.1"

# quic 协议选项
# transport.quic.keepalivePeriod = 10
# transport.quic.maxIdleTimeout = 30
# transport.quic.maxIncomingStreams = 100000

# 心跳配置，不建议修改默认值
# heartbeatTimeout 的默认值为 90。设置为负值可禁用它。
# transport.heartbeatTimeout = 90

# 每个代理中的连接池数量不会超过 maxPoolCount。
transport.maxPoolCount = 5

# 是否使用 tcp 流多路复用，默认为 true
# transport.tcpMux = true

# 指定 tcp mux 的保活间隔。
# 仅在 tcpMux 为 true 时有效。
# transport.tcpMuxKeepaliveInterval = 30

# tcpKeepalive 指定 frpc 和 frps 之间活动网络连接的保活探测间隔。
# 如果为负值，则禁用保活探测。
# transport.tcpKeepalive = 7200

# transport.tls.force 指定是否仅接受 TLS 加密连接。默认值为 false。
transport.tls.force = false

# transport.tls.certFile = "server.crt"
# transport.tls.keyFile = "server.key"
# transport.tls.trustedCaFile = "ca.crt"

# 如果要支持虚拟主机，必须设置用于监听的 http 端口（可选）
# 注意：http 端口和 https 端口可以与 bindPort 相同
vhostHTTPPort = 80
vhostHTTPSPort = 443

# vhost http 服务器的响应头超时时间（秒），默认为 60 秒
# vhostHTTPTimeout = 60

# tcpmuxHTTPConnectPort 指定服务器监听 TCP HTTP CONNECT 请求的端口。
# 如果值为 0，服务器将不会在单个端口上多路复用 TCP 请求。
# 如果不为 0，它将监听此端口上的 HTTP CONNECT 请求。
# 默认情况下，此值为 0。
# tcpmuxHTTPConnectPort = 1337

# 如果 tcpmuxPassthrough 为 true，frps 不会对流量进行任何更新。
# tcpmuxPassthrough = false

# 配置 web 服务器以启用 frps 的仪表板。
# 仪表板仅在设置了 webServer.port 时可用。
webServer.addr = "127.0.0.1"
webServer.port = 7500
webServer.user = "admin"
webServer.password = "admin"
# webServer.tls.certFile = "server.crt"
# webServer.tls.keyFile = "server.key"
# 仪表板资源目录（仅用于调试模式）
# webServer.assetsDir = "./static"

# 在仪表板监听器中启用 golang pprof 处理程序。
# 必须先设置仪表板端口
webServer.pprofEnable = false

# enablePrometheus 将在 webServer 的 /metrics api 上导出 prometheus 指标。
enablePrometheus = true

# 控制台或真实的日志文件路径，如 ./frps.log
log.to = "./frps.log"
# trace, debug, info, warn, error
log.level = "info"
log.maxDays = 3
# 当 log.to 为 console 时禁用日志颜色，默认为 false
log.disablePrintColor = false

# DetailedErrorsToClient 定义是否将特定错误（带调试信息）发送到 frpc。默认情况下，此值为 true。
detailedErrorsToClient = true

# auth.method 指定使用何种认证方法来验证 frpc 与 frps。
# 如果指定为 "token" - token 将被读入登录消息。
# 如果指定为 "oidc" - 将使用 OIDC 设置颁发 OIDC (Open ID Connect) token。默认情况下，此值为 "token"。
auth.method = "token"

# auth.additionalScopes 指定要包含认证信息的附加范围。
# 可选值为 HeartBeats, NewWorkConns。
# auth.additionalScopes = ["HeartBeats", "NewWorkConns"]

# 认证 token
auth.token = "12345678"

# 或者，你可以使用 tokenSource 从文件加载 token
# 这与 auth.token 互斥
# auth.tokenSource.type = "file"
# auth.tokenSource.file.path = "/etc/frp/token"

# oidc issuer 指定用于验证 OIDC token 的颁发者。
auth.oidc.issuer = ""
# oidc audience 指定 OIDC token 在验证时应包含的受众。
auth.oidc.audience = ""
# oidc skipExpiryCheck 指定是否跳过检查 OIDC token 是否过期。
auth.oidc.skipExpiryCheck = false
# oidc skipIssuerCheck 指定是否跳过检查 OIDC token 的颁发者声明是否与 OidcIssuer 中指定的颁发者匹配。
auth.oidc.skipIssuerCheck = false

# userConnTimeout 指定等待工作连接的最长时间。
# userConnTimeout = 10

# 仅允许 frpc 绑定您列出的端口。默认情况下，不会有任何限制。
allowPorts = [
{ start = 2000, end = 3000 },
{ single = 3001 },
{ single = 3003 },
{ start = 4000, end = 50000 }
]

# 每个客户端可以使用的最大端口数，默认值为 0 表示无限制
maxPortsPerClient = 0

# 如果 subDomainHost 不为空，可以在 frpc 的配置文件中设置子域名（当类型为 http 或 https 时）
# 当子域名为 test 时，路由使用的主机是 test.frps.com
subDomainHost = "frps.com"

# HTTP 请求的自定义 404 页面
# custom404Page = "/path/to/404.html"

# 指定 udp 数据包大小，单位为字节。如果未设置，默认值为 1500。
# 此参数在客户端和服务器之间应该相同。
# 它影响 udp 和 sudp 代理。
udpPacketSize = 1500

# NAT 打洞策略数据的保留时间。
natholeAnalysisDataReserveHours = 168

# ssh 隧道网关
# 如果要启用此功能，需要 bindPort 参数，其他参数是可选的。
# 默认情况下，此功能被禁用。如果 bindPort 大于 0，它将被启用。
# sshTunnelGateway.bindPort = 2200
# sshTunnelGateway.privateKeyFile = "/home/frp-user/.ssh/id_rsa"
# sshTunnelGateway.autoGenPrivateKeyPath = ""
# sshTunnelGateway.authorizedKeysFile = "/home/frp-user/.ssh/authorized_keys"

[[httpPlugins]]
name = "user-manager"
addr = "127.0.0.1:9000"
path = "/handler"
ops = ["Login"]

[[httpPlugins]]
name = "port-manager"
addr = "127.0.0.1:9001"
path = "/handler"
ops = ["NewProxy"]
```

以下是frpc\_full\_example.toml （0.65.0版本）toml文件的中文注释版：
---------------------------------------------------

```
# 此配置文件仅供参考。请勿直接使用此配置运行程序，因为它可能存在各种问题。

# 你的代理名称将被更改为 {user}.{proxy}
user = "your_name"

# IPv6 的字面地址或主机名必须用方括号括起来
# 例如 "[::1]:80", "[ipv6-host]:http" 或 "[ipv6-host%zone]:80"
# 对于单独的 serverAddr 字段，不需要方括号，如 serverAddr = "::"。
serverAddr = "0.0.0.0"
serverPort = 7000

# STUN 服务器用于帮助穿透 NAT 打洞。
# natHoleStunServer = "stun.easyvoip.com:3478"

# 决定首次登录失败时是否退出程序，否则持续重新登录到 frps
# 默认为 true
loginFailExit = true

# 控制台或真实的日志文件路径，如 ./frpc.log
log.to = "./frpc.log"
# trace, debug, info, warn, error
log.level = "info"
log.maxDays = 3
# 当 log.to 为 console 时禁用日志颜色，默认为 false
log.disablePrintColor = false

auth.method = "token"
# auth.additionalScopes 指定要包含认证信息的附加范围。
# 可选值为 HeartBeats, NewWorkConns。
# auth.additionalScopes = ["HeartBeats", "NewWorkConns"]

# 认证 token
auth.token = "12345678"

# 或者，你可以使用 tokenSource 从文件加载 token
# 这与 auth.token 互斥
# auth.tokenSource.type = "file"
# auth.tokenSource.file.path = "/etc/frp/token"

# oidc.clientID 指定在 OIDC 认证中用于获取 token 的客户端 ID。
# auth.oidc.clientID = ""
# oidc.clientSecret 指定在 OIDC 认证中用于获取 token 的客户端密钥。
# auth.oidc.clientSecret = ""
# oidc.audience 指定 OIDC 认证中 token 的受众。
# auth.oidc.audience = ""
# oidc.scope 指定 OIDC 认证中 token 的权限（如果 AuthenticationMethod == "oidc"）。默认情况下，此值为 ""。
# auth.oidc.scope = ""
# oidc.tokenEndpointURL 指定实现 OIDC Token Endpoint 的 URL。
# 它将用于获取 OIDC token。
# auth.oidc.tokenEndpointURL = ""

# oidc.additionalEndpointParams 指定要发送到 OIDC Token Endpoint 的附加参数。
# 例如，如果要指定 "audience" 参数，可以设置如下。
# frp 将把 "audience=" "var1=" 添加到附加参数中。
# auth.oidc.additionalEndpointParams.audience = "https://dev.auth.com/api/v2/"
# auth.oidc.additionalEndpointParams.var1 = "foobar"

# OIDC TLS 和代理配置
# 指定用于验证 OIDC token endpoint 的 TLS 证书的自定义 CA 证书文件。
# 当 OIDC 提供者使用自签名证书或自定义 CA 时，这很有用。
# auth.oidc.trustedCaFile = "/path/to/ca.crt"

# 跳过 OIDC token endpoint 的 TLS 证书验证。
# 不安全：仅用于调试目的，不建议在生产环境中使用。
# auth.oidc.insecureSkipVerify = false

# 指定 OIDC token endpoint 连接的代理服务器。
# 支持 http、https、socks5 和 socks5h 代理协议。
# 如果未指定，OIDC 连接不使用代理。
# auth.oidc.proxyURL = "http://proxy.example.com:8080"

# 设置管理地址，通过 http api 控制 frpc 的操作，如重载
webServer.addr = "127.0.0.1"
webServer.port = 7400
webServer.user = "admin"
webServer.password = "admin"
# 管理资源目录。默认情况下，这些资源与 frpc 捆绑在一起。
# webServer.assetsDir = "./static"

# 在管理监听器中启用 golang pprof 处理程序。
webServer.pprofEnable = false

# 与服务器建立连接的最长等待时间。默认值为 10 秒。
# transport.dialServerTimeout = 10

# dialServerKeepalive 指定 frpc 和 frps 之间活动网络连接的保活探测间隔。
# 如果为负值，则禁用保活探测。
# transport.dialServerKeepalive = 7200

# 将提前建立连接，默认值为零
transport.poolCount = 5

# 是否使用 tcp 流多路复用，默认为 true，必须与 frps 相同
# transport.tcpMux = true

# 指定 tcp mux 的保活间隔。
# 仅在启用 tcpMux 时有效。
# transport.tcpMuxKeepaliveInterval = 30

# 用于连接到服务器的通信协议
# 目前支持 tcp、kcp、quic、websocket 和 wss，默认为 tcp
transport.protocol = "tcp"

# 连接服务器时设置客户端绑定 ip，默认为空。
# 仅当 protocol = tcp 或 websocket 时，该值才会被使用。
transport.connectServerLocalIP = "0.0.0.0"

# 如果要通过 http 代理、socks5 代理或 ntlm 代理连接 frps，可以在此处或全局环境变量中设置 proxyURL
# 仅在 protocol 为 tcp 时有效
# transport.proxyURL = "http://user:passwd@192.168.1.128:8080"
# transport.proxyURL = "socks5://user:passwd@192.168.1.128:1080"
# transport.proxyURL = "ntlm://user:passwd@192.168.1.128:2080"

# quic 协议选项
# transport.quic.keepalivePeriod = 10
# transport.quic.maxIdleTimeout = 30
# transport.quic.maxIncomingStreams = 100000

# 如果 tls.enable 为 true，frpc 将通过 tls 连接 frps。
# 自 v0.50.0 起，默认值已更改为 true，并且默认启用 tls。
transport.tls.enable = true

# transport.tls.certFile = "client.crt"
# transport.tls.keyFile = "client.key"
# transport.tls.trustedCaFile = "ca.crt"
# transport.tls.serverName = "example.com"

# 如果 disableCustomTLSFirstByte 设置为 false，frpc 将在启用 tls 时使用
# 第一个自定义字节与 frps 建立连接。
# 自 v0.50.0 起，默认值已更改为 true，并且默认禁用第一个自定义字节。
# transport.tls.disableCustomTLSFirstByte = true

# 心跳配置，不建议修改默认值。
# heartbeatInterval 的默认值为 10，heartbeatTimeout 的默认值为 90。设置为负值
# 可禁用它。
# transport.heartbeatInterval = 30
# transport.heartbeatTimeout = 90

# 指定 dns 服务器，因此 frpc 将使用此服务器而不是默认服务器
# dnsServer = "8.8.8.8"

# 你想要启动的代理名称。
# 默认为空，表示所有代理。
# start = ["ssh", "dns"]

# 'start' 的替代方法：你可以使用 'enabled' 字段单独控制每个代理。
# 在代理配置中设置 'enabled = false' 可禁用它。
# 如果未设置 'enabled' 或设置为 true，则代理默认启用。
# 'enabled' 字段提供了更精细的控制，建议使用它而不是 'start'。

# 指定 udp 数据包大小，单位为字节。如果未设置，默认值为 1500。
# 此参数在客户端和服务器之间应该相同。
# 它影响 udp 和 sudp 代理。
udpPacketSize = 1500

# 功能门控允许你启用或禁用实验性功能
# 格式是功能名称到布尔值的映射
# 你可以启用特定功能：
#featureGates = { VirtualNet = true }

# VirtualNet 实验性虚拟网络功能的设置
# 虚拟网络功能需要在上面启用 VirtualNet 功能门控
# virtualNet.address = "100.86.1.1/24"

# 客户端的附加元数据。
metadatas.var1 = "abc"
metadatas.var2 = "123"

# 包含其他代理配置文件。
# includes = ["./confd/*.ini"]

[[proxies]]
# 'ssh' 是唯一的代理名称
# 如果全局 user 不为空，它将被更改为 {user}.{proxy}，例如 'your_name.ssh'
name = "ssh"
type = "tcp"
# 启用或禁用此代理。true 或省略此字段表示启用，false 表示禁用。
# enabled = true
localIP = "127.0.0.1"
localPort = 22
# 限制此代理的带宽，单位为 KB 和 MB
transport.bandwidthLimit = "1MB"
# 限制带宽的位置，可以是 'client' 或 'server'，默认为 'client'
transport.bandwidthLimitMode = "client"
# 如果为 true，此代理的流量将被加密，默认为 false
transport.useEncryption = false
# 如果为 true，流量将被压缩
transport.useCompression = false
# frps 监听的远程端口
remotePort = 6001
# frps 将对同一组中的代理进行负载均衡连接
loadBalancer.group = "test_group"
# 组应具有相同的组密钥
loadBalancer.groupKey = "123456"
# 为后端服务启用健康检查，目前支持 'tcp' 和 'http'。
# frpc 将连接本地服务的端口以检测其健康状态
healthCheck.type = "tcp"
# 健康检查连接超时
healthCheck.timeoutSeconds = 3
# 如果连续失败 3 次，代理将从 frps 中移除
healthCheck.maxFailed = 3
# 每 10 秒进行一次健康检查
healthCheck.intervalSeconds = 10
# 每个代理的附加元信息。它将传递给服务器端插件使用。
metadatas.var1 = "abc"
metadatas.var2 = "123"
# 你可以通过注解为代理添加一些额外信息。
# 这些注解将显示在 frps 仪表板上。
[proxies.annotations]
key1 = "value1"
"prefix/key2" = "value2"

[[proxies]]
name = "ssh_random"
type = "tcp"
localIP = "192.168.31.100"
localPort = 22
# 如果 remotePort 为 0，frps 将为你分配一个随机端口
remotePort = 0

[[proxies]]
name = "dns"
type = "udp"
localIP = "114.114.114.114"
localPort = 53
remotePort = 6002

# 将你的域名解析到 [serverAddr]，这样你就可以使用 http://web01.yourdomain.com 浏览 web01，使用 http://web02.yourdomain.com 浏览 web02
[[proxies]]
name = "web01"
type = "http"
localIP = "127.0.0.1"
localPort = 80
# http 用户名和密码是 http 协议的安全认证
# 如果未设置，你可以在不进行认证的情况下访问此 customDomains
httpUser = "admin"
httpPassword = "admin"
# 如果 frps 的域名是 frps.com，那么你可以通过 URL http://web01.frps.com 访问 [web01] 代理
subdomain = "web01"
customDomains = ["web01.yourdomain.com"]
# locations 仅适用于 http 类型
locations = ["/", "/pic"]
# 如果 http basic auto user 是 abc，则将请求路由到此服务
# routeByHTTPUser = abc
hostHeaderRewrite = "example.com"
requestHeaders.set.x-from-where = "frp"
responseHeaders.set.foo = "bar"
healthCheck.type = "http"
# frpc 将向本地 http 服务发送 GET http 请求 '/status'
# 当它返回 2xx http 响应代码时，http 服务处于活动状态
healthCheck.path = "/status"
healthCheck.intervalSeconds = 10
healthCheck.maxFailed = 3
healthCheck.timeoutSeconds = 3
# 设置健康检查头
healthCheck.httpHeaders=[
{ name = "x-from-where", value = "frp" }
]

[[proxies]]
name = "web02"
type = "https"
# 通过将 enabled 设置为 false 来禁用此代理
# enabled = false
localIP = "127.0.0.1"
localPort = 8000
subdomain = "web02"
customDomains = ["web02.yourdomain.com"]
# 如果不为空，frpc 将使用代理协议将连接信息传输到你的本地服务
# v1 或 v2 或空
transport.proxyProtocolVersion = "v2"

[[proxies]]
name = "tcpmuxhttpconnect"
type = "tcpmux"
multiplexer = "httpconnect"
localIP = "127.0.0.1"
localPort = 10701
customDomains = ["tunnel1"]
# routeByHTTPUser = "user1"

[[proxies]]
name = "plugin_unix_domain_socket"
type = "tcp"
remotePort = 6003
# 如果定义了 plugin，localIP 和 localPort 将无用
# plugin 将处理从 frps 获得的连接
[proxies.plugin]
type = "unix_domain_socket"
unixPath = "/var/run/docker.sock"

[[proxies]]
name = "plugin_http_proxy"
type = "tcp"
remotePort = 6004
[proxies.plugin]
type = "http_proxy"
httpUser = "abc"
httpPassword = "abc"

[[proxies]]
name = "plugin_socks5"
type = "tcp"
remotePort = 6005
[proxies.plugin]
type = "socks5"
username = "abc"
password = "abc"

[[proxies]]
name = "plugin_static_file"
type = "tcp"
remotePort = 6006
[proxies.plugin]
type = "static_file"
localPath = "/var/www/blog"
stripPrefix = "static"
httpUser = "abc"
httpPassword = "abc"

[[proxies]]
name = "plugin_https2http"
type = "https"
customDomains = ["test.yourdomain.com"]
[proxies.plugin]
type = "https2http"
localAddr = "127.0.0.1:80"
crtPath = "./server.crt"
keyPath = "./server.key"
hostHeaderRewrite = "127.0.0.1"
requestHeaders.set.x-from-where = "frp"

[[proxies]]
name = "plugin_https2https"
type = "https"
customDomains = ["test.yourdomain.com"]
[proxies.plugin]
type = "https2https"
localAddr = "127.0.0.1:443"
crtPath = "./server.crt"
keyPath = "./server.key"
hostHeaderRewrite = "127.0.0.1"
requestHeaders.set.x-from-where = "frp"

[[proxies]]
name = "plugin_http2https"
type = "http"
customDomains = ["test.yourdomain.com"]
[proxies.plugin]
type = "http2https"
localAddr = "127.0.0.1:443"
hostHeaderRewrite = "127.0.0.1"
requestHeaders.set.x-from-where = "frp"

[[proxies]]
name = "plugin_http2http"
type = "tcp"
remotePort = 6007
[proxies.plugin]
type = "http2http"
localAddr = "127.0.0.1:80"
hostHeaderRewrite = "127.0.0.1"
requestHeaders.set.x-from-where = "frp"

[[proxies]]
name = "plugin_tls2raw"
type = "tcp"
remotePort = 6008
[proxies.plugin]
type = "tls2raw"
localAddr = "127.0.0.1:80"
crtPath = "./server.crt"
keyPath = "./server.key"

[[proxies]]
name = "secret_tcp"
# 如果类型为 secret tcp，则 remotePort 无用
# 想要连接本地端口的人应该部署另一个具有 stcp 代理的 frpc，并且角色为 visitor
type = "stcp"
# secretKey 用于访客的认证
secretKey = "abcdefg"
localIP = "127.0.0.1"
localPort = 22
# 如果不为空，则只有来自指定用户的访客才能连接。
# 否则，来自同一用户的访客可以连接。'*' 表示允许所有用户。
allowUsers = ["*"]

[[proxies]]
name = "p2p_tcp"
type = "xtcp"
secretKey = "abcdefg"
localIP = "127.0.0.1"
localPort = 22
# 如果不为空，则只有来自指定用户的访客才能连接。
# 否则，来自同一用户的访客可以连接。'*' 表示允许所有用户。
allowUsers = ["user1", "user2"]

# NAT 穿透配置（可选）
[proxies.natTraversal]
# 禁用使用本地网络接口（辅助地址）进行 NAT 穿透。
# 启用后，将仅使用 STUN 发现的公共地址。
# 当你有慢速 VPN 连接时，这可以提高性能。
# 默认值：false
disableAssistedAddrs = false

[[proxies]]
name = "vnet-server"
type = "stcp"
secretKey = "your-secret-key"
[proxies.plugin]
type = "virtual_net"

# frpc 角色 visitor -> frps -> frpc 角色 server
[[visitors]]
name = "secret_tcp_visitor"
type = "stcp"
# 你想要访问的服务器名称
serverName = "secret_tcp"
secretKey = "abcdefg"
# 连接到此地址以访问 stcp 服务器
bindAddr = "127.0.0.1"
# bindPort 可以小于 0，表示不绑定到端口，只接收从其他访客重定向的连接。
# （SUDP 目前不支持此功能）
bindPort = 9000

[[visitors]]
name = "p2p_tcp_visitor"
type = "xtcp"
# 如果未设置服务器用户，则默认为当前用户
serverUser = "user1"
serverName = "p2p_tcp"
secretKey = "abcdefg"
bindAddr = "127.0.0.1"
# bindPort 可以小于 0，表示不绑定到端口，只接收从其他访客重定向的连接。
# （SUDP 目前不支持此功能）
bindPort = 9001
# 当需要自动隧道持久性时，将其设置为 true
keepTunnelOpen = false
# 当 keepTunnelOpen 设置为 true 时有效，每小时打洞尝试次数
maxRetriesAnHour = 8
minRetryInterval = 90
# fallbackTo = "stcp_visitor"
# fallbackTimeoutMs = 500

# NAT 穿透配置（可选）
[visitors.natTraversal]
# 禁用使用本地网络接口（辅助地址）进行 NAT 穿透。
# 启用后，将仅使用 STUN 发现的公共地址。
# 默认值：false
disableAssistedAddrs = false

[[visitors]]
name = "vnet-visitor"
type = "stcp"
serverName = "vnet-server"
secretKey = "your-secret-key"
bindPort = -1
[visitors.plugin]
type = "virtual_net"
destinationIP = "100.86.0.1"
```